\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{fancyvrb}
\usepackage{graphicx}

% Geometry
\geometry{a4paper, margin=1in}

% Hyperref setup for clickable links
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue
}

% Paragraph spacing
\setlength{\parskip}{0.5em}
\setlength{\parindent}{0pt}

% Title
\title{OOP Project Sprint 1, 2 \& 3 Outline and Contribution Report}
\author{PlayOps - A retro videogame \& gaming hardware retail logistics solution \\ BSc in Artificial Intelligence}
\date{Assigning / Accepting Professor: Prof. Evis Plaku \\ January 21, 2026}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Project Overview}
PlayOps is a logistics solution designed for retailers focused on the selling and renting of video games, as well as the sale of gaming hardware. It allows operators to add, remove, search, display, and manage customers, transactions, and games.

PlayOps strives to align with OOP principles, taking pride in its development process and maintaining crucial awareness to principles, such as those of:
\begin{itemize}
    \item \textbf{Sprint 1}: Fundamental object oriented design, management through arrays/lists encapsulation, modular design and data abstraction.
    \item \textbf{Sprint 2}: Inheritance based - interface compliant design, polymorphic behavior, encapsulation with access modifiers, pre-implemented and custom exception handling, file persistence.
    \item \textbf{Sprint 3}: Advanced architectural separation (Repository/Service layers), persistent data management via HashMaps, and GUI integration using JavaFX with Maven.
\end{itemize}

\section{UML Class Diagram}
The UML diagram explains the structure and relationships of the components within this project.

\begin{center}
\includegraphics[scale=0.3]{PlayOps-alpha-0.1.png}
\end{center}

\section{Sprint 1}
\subsection{Project Structure and Design}
\begin{quote}
The project follows a modular object-oriented structure:
\begin{itemize}
\item \textbf{com.playops.model.Customer.java} — Manages customer data and an instance of validation in the email entries.
\item \textbf{com.playops.model.Game.java} — Represents the game properties and their attributes.
\item \textbf{com.playops.store.Store.java} — Manages lists of customers and games.
\item \textbf{com.playops.app.Main.java} — Entry point that handles user interaction.
\end{itemize}

Each class was designed with primary OOP philosophy of dividing work into classes with reusability and user convenience.
\end{quote}

\section{Sprint 2}
\subsection{Improved Project Structure and Design}
Project design has relied on collaborative work heavily utilizing git.

The updated structure altered the foundations in a way that honors the simplistic approach with few classes that have now expanded to a plethora of specialized single-purpose classes.

The project utilizes the Product, Customer, and Transaction classes, all intertwined in the connecting Store class to do most of the heavy lifting, assisted by the interfaces and exceptions that make possible the seamless integration of methods catering to necessary functionality. Below is an ASCII representation of the logical implementation.

{\small
\begin{verbatim}
com.playops
|
+-- app
|   +-- Main
|       - Entry point of the application
|       - Uses Store, Customers, Products, PaymentMethods, Transactions
|
+-- exceptions
|   +-- CustomException
|   +-- FileProcessingException
|   +-- InsufficientQuantityException
|   +-- InvalidEmailException
|   +-- ItemNotFoundException
|   +-- PaymentException
|       - Used by PaymentProcessor, Store, and PaymentMethod implementations
|
+-- interfaces
|   +-- Buyable
|   |   - Implemented by Product/Game classes
|   +-- PaymentMethod
|   |   - Implemented by CardPayment, CashPayment
|   +-- Rentable
|       - Implemented by PhysicalGame
|
+-- model
|   +-- Product
|   |   - Superclass of Hardware and Game
|   |   - Implements Buyable
|   |
|   +-- Hardware
|   |   +-- Console
|   |   +-- Desktop
|   |   +-- Laptop
|   |
|   +-- Game
|   |   +-- DigitalGame
|   |   +-- PhysicalGame (also implements Rentable)
|   |
|   +-- Customer
|   |   - Used by Store and Transaction
|   |
|   +-- Transaction
|       - References Product and Customer
|       - Stored in Store
|
+-- payment
|   +-- PaymentProcessor
|   |   - Processes PaymentMethod (CashPayment, CardPayment)
|   +-- CardPayment
|   +-- CashPayment
|
+-- store
    +-- Store
        - Holds ArrayLists of Products, Customers, Transactions
        - Performs buyProduct, rentGame, add/remove/display operations
        - Uses PaymentProcessor to handle payments
\end{verbatim}
}

\subsection{Inheritance, Polymorphism, Interfaces}
The project architecture heavily relies on inheritance. The most evident example is that of the PhysicalGame, DigitalGame, Laptop, Desktop, Console classes. All these classes stem from a common abstract class, Product. Product provides the ambiguous definitions that all products have, and extends to a second layer of abstraction where the abstract classes of Game and Hardware lay the foundations for the former pair of atomic classes.

Polymorphism and Interfaces work hand-in-hand, where polymorphism takes shape in the overriding of methods in classes implementing interfaces, populating fields demanded by the latter.

\subsection{Exception Handling}
Exceptions exist, and the way we handle them matters more and more. It is our weaknesses that make us stronger, and our response to stress, anxiety, panic and turmoil are what dictates if we stand strong in the real world. Similarly, by utilizing the exceptions class that enables the seamless interruption of an action that violates a constraint, we are able to have a logic smarter than checking values with if conditions. To access this powerful utilization we use try-catch blocks. By providing our expected runtime scenario in the try section, and the exceptions that may occur in the catch sections, we create an environment where all conditions that would violate a logical semantic operation are caught and tended to.

A few examples of situations where the program catches exceptions and recovers can be found below. If these exceptions were to not be caught, in most cases, the default response from the JVM is to terminate.

\begin{itemize}
    \item \textbf{Missing Files:} If say, transactions.txt doesn’t exist, the message "No transactions file found. Starting fresh." is printed and the program proceeds to run.
    \item \textbf{Invalid Input:} When a user tries to add a customer with an invalid email, the app prints the error but does not terminate.
    \item \textbf{Payment Failures:} If a payment fails (usually insufficient payment), the app prints a failure message, and no transaction is recorded.
    \item \textbf{Out of Stock:} If a product is unavailable, the purchase/rental is blocked, and the user is informed.
\end{itemize}

\section{Sprint 3}
\subsection{Architectural Evolution and Persistence}
Sprint 3 marked a significant transition from a monolithic Store-centric design to a more robust, tiered architecture. We introduced Repository and Service layers to further separate concerns, aligning with industry standards for maintainability.

Key improvements include:
\begin{itemize}
    \item \textbf{HashMap Implementation:} Data storage moved from simple lists to HashMaps within repositories, allowing for $O(1)$ lookup times and more efficient data retrieval by unique identifiers.
    \item \textbf{Enhanced File Persistence:} Robust CSV handling was enforced to ensure that all changes to customers, inventory, and transactions are immediately reflected in local storage, preventing data loss between sessions.
    \item \textbf{Service Layer:} Business logic was extracted from the model and UI controllers into dedicated services (AdminService, StoreService), ensuring a clean separation between data processing and user interface.
\end{itemize}

\subsection{JavaFX and Maven Integration}
To move beyond the console-based interaction, the project was migrated to a Maven-based build system to manage JavaFX dependencies. This enabled the development of a dynamic graphical user interface featuring:
\begin{itemize}
    \item \textbf{Admin Login:} A secure entry point for administrators to manage the system.
    \item \textbf{Dashboard View:} A multi-tabbed interface utilizing FXML and CSS. One tab focuses on real-time stock management, while the other provides a comprehensive overview of sales and transaction history.
    \item \textbf{MVC Pattern:} Implementation of the Model-View-Controller pattern to manage the complex interactions between the FXML layouts and the backend services.
\end{itemize}

\section{Team Roles and Contributions}
\begin{longtable}{p{4cm} p{11cm}}
    \textbf{Name} & \textbf{Responsibilities and Contributions} \\
    \hline
    Blevis Allushi & Co-author. Integrated Maven and JavaFX to transition the project to a GUI. Developed the Login and Dashboard controllers. Implemented dynamic tabs for admin management and sales/stock visualization. Adapted the existing structure to support the MVC pattern. \\
    \hline
    Kristi Seraj & Co-author. Further separated individual OOP principles through the introduction of Repositories and Services. Enforced strict file persistence for all data models. Implemented HashMap-based data structures to optimize search and storage efficiency. \\
\end{longtable}

\section{Reflection}
The third sprint challenged our ability to integrate modern frameworks like JavaFX while maintaining the integrity of our OOP foundations. Moving to a Repository/Service pattern and implementing HashMaps significantly improved the application's scalability and performance. The transition from console to GUI represents a major milestone in making PlayOps a production-ready retail solution.

\end{document}